#ifndef CUSTOMERS_HEADER
#define CUSTOMERS_HEADER
#define MAX_QUEUE_SIZE 20
#define MAX_ITEMS_IN_CART 10
#define MAX_SHOPPING_TIME 10

/* End Thresholds */
#define CREATION_THRESHOLD 200 // The max number of peoples that we can generate
#define UNSERVED_THRESHOLD 120
#define UNHAPPY_THRESHOLD 20
#define SATISFIED_THRESHOLD 50
/* End Thresholds */

#define SATISFIED_RATIO 85 // 85% SATISFIED AND 15% UNHAPPY IN THE END RESULT


// Person leaving of stay depend on his patience
enum PatienceDegree {LOW, MEDIUM, HIGH, VERY_HIGH};

// The person end status
enum END{CREATION, UNSERVED, UNHAPPY, SATISFIED};

// For change the size of the queue
enum STEP{INCREMENT, DECREMENT};



struct Customer {
    int id;
    int num_items;
    int shopping_time;
    int cart[MAX_ITEMS_IN_CART];
    float total_price;
    enum PatienceDegree patience_degree;
} ;



/** functions starts ****************************************************************************************/


#include "functions.h" // num_items of all , items array
#include "constants.h" // Config c
#include "header.h" // Config c
#include "shared_memories.h"
#include "semphores.h"
#include "message_queues.h"

Config c;
static int totalCustomers = 0;
void increment_total_customers();
int get_total_customers();

/** Random number generator --------------------------------------------------------------------------------------*/
int generate_random_number() {
    // Generate a random number between 1 and MAX_ITEMS_IN_CART
    return (rand() % MAX_ITEMS_IN_CART) + 1;
}

// Function to generate a random shopping time
int generate_shopping_time() {

    return (rand() % c.shopping_time_max) + 1;


}

// Function to generate a random number of customers each interval
int generate_customers_per_interval() {
    // Generate a random number of customers between 1 and customerPerInterval
    return (rand() % c.customers_per_interval) + 1;
}

/** Random number generator end ----------------------------------------------------------------------------------*/


void pick_up_items(struct Customer *customer, Item *shared_items) {



    srand((unsigned int)time(NULL) + customer->id);


    printf("Customer %d is picking up items:\n", customer->id);

    // Generate and print a random number between 1 and MAX_ITEMS_IN_CART
    int random_number = generate_random_number();
    printf("Random Number: %d ... customer %d \n", random_number, customer->id);

    for (int i = 0; i < random_number; ++i) {
        // Check if all items have quantity = 0
        int allItemsZero = 1;
        for (int j = 0; j < num_items; ++j) {
            if (shared_items[j].quantity > 0) {
                allItemsZero = 0;
                break;
            }
        }

        if (allItemsZero) {
            // All items have quantity = 0, break the loop
            sem_post(pick_up_items_mutex);
            printf("No more items to pick. Customer %d finished picking up items.\n", customer->id);
            return;
        }

        int random_index;
        do {
            random_index = rand() % num_items;
        } while (shared_items[random_index].quantity <= 0);



        shared_items[random_index].quantity--;
        customer->cart[i] = random_index;
        customer->num_items++;

        printf("Customer %d picked up %s\n", customer->id, shared_items[customer->cart[i]].name);
        // Release the mutex


    }

    printf("Customer %d finished picking up items.\n", customer->id);
}


void fill_cart(struct Customer *customer) {

    int shmid = shmget(ITM_SMKEY, num_items * sizeof(Item), 0666);
    if (shmid == -1) {
        perror("shmget");
        exit(EXIT_FAILURE);
    }

    Item *shared_items = (Item *)shmat(shmid, NULL, 0);
    if (shared_items == (Item *)-1) {
        perror("shmat");
        exit(EXIT_FAILURE);
    }

    // Acquire semaphore for picking up items
    pick_up_items_mutex = get_semaphore(Pick_key);
    lock_sem(pick_up_items_mutex);

    increment_total_customers(); // Increment totalCustomers and assign ID

    // Critical section starts here
    customer->id = get_total_customers(); // Increment totalCustomers and assign ID
    customer->num_items = 0;

    printf("\n----------------------------------------\n");
    pick_up_items(customer, shared_items);

    printf("\n----------------------------------------\n");
    // Simulate shopping time
    int random_shopping_time = generate_shopping_time();
    sleep(random_shopping_time);

    // Critical section ends here

    // Release semaphore
    unlock_sem(pick_up_items_mutex);
    sem_close(pick_up_items_mutex);

    // Detach from shared memory
    if (shmdt(shared_items) == -1) {
        perror("shmdt");
        exit(EXIT_FAILURE);
    }

    return;

}



int get_total_customers() {
    int shmid = shmget(CUS_NUM_KEY, sizeof(SharedData), 0666);
    if (shmid == -1) {
        perror("shmget");
        exit(EXIT_FAILURE);
    }

    SharedData *shared_data = (SharedData *)shmat(shmid, NULL, 0);
    if (shared_data == (void *)-1) {
        perror("shmat");
        exit(EXIT_FAILURE);
    }

    // mutex code

    customers_total_mutex = get_semaphore(total_customers_key);

    lock_sem(customers_total_mutex);


    int total_cus = shared_data->totalCustomers;

    unlock_sem(customers_total_mutex);
    close_semaphore(customers_total_mutex);

    //end mutex code

    if (shmdt(shared_data) == -1) {
        perror("shmdt");
        exit(EXIT_FAILURE);
    }

    return total_cus;
}

void send_customer_message(struct Customer *customer) {


    int queue = get_queue(C_KEY);

    customerQueue customer_data;
    customer_data.customer_id = customer->id;
    customer_data.item_count = customer->num_items;
    customer_data.total_price = customer->total_price;


    // mutex code

    customers_total_mutex = get_semaphore(queu1_key);

    lock_sem(customers_total_mutex);

    /* increase_cashier_queue_size(cashier_id);
     int size = get_cashier_queue_size(cashier_id);
     */


    sleep(4);

    //  printf("Queue size for %d is %d after assigning customer\n", cashier_id, size);

    //fflush(stdout); // Flush the output buffer to ensure immediate display

    // Send the message
    if (msgsnd(queue, &customer_data, sizeof(customer_data), 0) == -1) {
        perror("customer_data");
        exit(EXIT_FAILURE);
    }



    unlock_sem(customers_total_mutex);
    close_semaphore(customers_total_mutex);

    //end mutex code



}

void send_customer_message2(struct Customer *customer) {


    int queue = get_queue(C_KEY2);

    customerQueue customer_data;
    customer_data.customer_id = customer->id;
    customer_data.item_count = customer->num_items;
    customer_data.total_price = customer->total_price;


    // mutex code

    customers_total_mutex = get_semaphore(queu2_key);

    lock_sem(customers_total_mutex);

    /* increase_cashier_queue_size(cashier_id);
     int size = get_cashier_queue_size(cashier_id);
     */


    sleep(4);

    //  printf("Queue size for %d is %d after assigning customer\n", cashier_id, size);

    //fflush(stdout); // Flush the output buffer to ensure immediate display

    // Send the message
    if (msgsnd(queue, &customer_data, sizeof(customer_data), 0) == -1) {
        perror("customer_data");
        exit(EXIT_FAILURE);
    }



    unlock_sem(customers_total_mutex);
    close_semaphore(customers_total_mutex);

    //end mutex code



}

void send_customer_message3(struct Customer *customer) {


    int queue = get_queue(C_KEY3);

    customerQueue customer_data;
    customer_data.customer_id = customer->id;
    customer_data.item_count = customer->num_items;
    customer_data.total_price = customer->total_price;


    // mutex code

    customers_total_mutex = get_semaphore(queu3_key);

    lock_sem(customers_total_mutex);

    /* increase_cashier_queue_size(cashier_id);
     int size = get_cashier_queue_size(cashier_id);
     */


    sleep(4);

    //  printf("Queue size for %d is %d after assigning customer\n", cashier_id, size);

    //fflush(stdout); // Flush the output buffer to ensure immediate display

    // Send the message
    if (msgsnd(queue, &customer_data, sizeof(customer_data), 0) == -1) {
        perror("customer_data");
        exit(EXIT_FAILURE);
    }



    unlock_sem(customers_total_mutex);
    close_semaphore(customers_total_mutex);

    //end mutex code



}

void increment_total_customers() {
    // Get the shared memory ID
    int shmid = shmget(CUS_NUM_KEY, sizeof(SharedData), 0666);
    if (shmid == -1) {
        perror("shmget");
        exit(EXIT_FAILURE);
    }

    // Attach to the shared memory
    SharedData *shared_data = (SharedData *)shmat(shmid, NULL, 0);
    if (shared_data == (void *)-1) {
        perror("shmat");
        exit(EXIT_FAILURE);
    }

    // Acquire the semaphore before modifying shared memory
    sem_t *customers_total_mutex = get_semaphore(total_customers_key);

    lock_sem(customers_total_mutex);

    // Increment the totalCustomers value
    shared_data->totalCustomers++;

    // Release the semaphore
    unlock_sem(customers_total_mutex);
    close_semaphore(customers_total_mutex);

    // Detach from shared memory
    if (shmdt(shared_data) == -1) {
        perror("shmdt");
        exit(EXIT_FAILURE);
    }
}



float get_score1_cashier1() {
    int shmid = shmget(cashier1_score_key, sizeof(cashier_score1_shared_memory), 0666);
    if (shmid == -1) {
        perror("shmget");
        exit(EXIT_FAILURE);
    }

    cashier_score1_shared_memory *shared_data = (cashier_score1_shared_memory *)shmat(shmid, NULL, 0);
    if (shared_data == (void *)-1) {
        perror("shmat");
        exit(EXIT_FAILURE);
    }

    // mutex code

    sem_t* score1_mutex = get_semaphore(cashSem1_score_key);

    lock_sem(score1_mutex);


    float score1 = shared_data->score1 ;

    unlock_sem(score1_mutex);
    close_semaphore(score1_mutex);

    //end mutex code

    if (shmdt(shared_data) == -1) {
        perror("shmdt");
        exit(EXIT_FAILURE);
    }

    return score1;
}

float get_score2_cashier2(){

    int shmid = shmget(cashier2_score_key, sizeof(cashier_score2_shared_memory), 0666);
    if (shmid == -1) {
        perror("shmget");
        exit(EXIT_FAILURE);
    }

    cashier_score2_shared_memory *shared_data = (cashier_score2_shared_memory *)shmat(shmid, NULL, 0);
    if (shared_data == (void *)-1) {
        perror("shmat");
        exit(EXIT_FAILURE);
    }

    // mutex code

    sem_t* score2_mutex = get_semaphore(cashSem2_score_key);

    lock_sem(score2_mutex);


    float score2 = shared_data->score2 ;

    unlock_sem(score2_mutex);
    close_semaphore(score2_mutex);

    //end mutex code

    if (shmdt(shared_data) == -1) {
        perror("shmdt");
        exit(EXIT_FAILURE);
    }

    return score2;

}

float get_score3_cashier3(){

    int shmid = shmget(cashier3_score_key, sizeof(cashier_score3_shared_memory), 0666);
    if (shmid == -1) {
        perror("shmget");
        exit(EXIT_FAILURE);
    }

    cashier_score3_shared_memory *shared_data = (cashier_score3_shared_memory *)shmat(shmid, NULL, 0);
    if (shared_data == (void *)-1) {
        perror("shmat");
        exit(EXIT_FAILURE);
    }

    // mutex code

    sem_t* score3_mutex = get_semaphore(cashSem3_score_key);

    lock_sem(score3_mutex);


    float score3 = shared_data->score3 ;

    unlock_sem(score3_mutex);
    close_semaphore(score3_mutex);

    //end mutex code

    if (shmdt(shared_data) == -1) {
        perror("shmdt");
        exit(EXIT_FAILURE);
    }

    return score3;

}




#endif

